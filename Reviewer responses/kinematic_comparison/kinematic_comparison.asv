clear; clc; clf; close all

%% Setup saveFig   
    saveFig = true;
    saveDir = 'C:\Users\pmari\OneDrive - University of Pittsburgh\Documents\Posture\Paper\20231002\Figure 6';
    set(0, 'DefaultFigureRenderer', 'painters');
    
%% Set parameters
   numIterations = 30;
   cutoffNumTraj = 10; %Num trials that must be present in a condition to keep it for analysis 
   
%% Datasets to include in analysis 
    reachDatasetList = {'E20210706','E20210707','E20210708',...
        'N20190222','N20190226','N20190227','N20190228','N20190307'...
        'R20200221','R20200222'};    
    bciDatasetList = {'E20200316','E20200317','E20200318','E20200319','N20171215','N20180221','R20201020','R20201021'};         
    isoDatasetList = {'E20200116','E20200117','E20200120'};    

%% Main loop
    resultStruct = struct('animal',[],'dataset',[],'result',[]);
    structInd = 1;
    for datasetList = bciDatasetList%{'R20201021'}%{'R20200221','N20190222'}%{'N20190222','N20190226','R20200221','R20200222'}%reachDatasetList%{'E20200316'}%bciDatasetList% reachDatasetList%{'E20210707','N20190226','R20200221'}%{'E20200316','N20171215','R20201020'}%{ 'R20200221'}%bciDatasetList%{'E20210706','E20210707','E20210708','E20210709'}%reachDatasetList
        %% Set up trajStruct
        %Load data
        dataset = datasetList{1,1};
        [Data,zScoreParams] = loadData(dataset);
        [Data] = removeShortBCIandIsoTrials(Data,dataset);
        %Get trajStruct
        [condFields,trajFields,trialInclStates,binWidth,kernelStdDev] = getTrajStructParamsKinematicComparison(dataset);
        trajStruct = getTrajStruct(Data,condFields,trajFields,trialInclStates,binWidth,kernelStdDev,'zScoreParams',zScoreParams,'getTrialAverages',false);  
        %Remove any conditions for which there weren't enough trials
        [numCondTrials] = getNumCondTrials(trajStruct,'showHist',false);         
        trajStruct = trajStruct(numCondTrials >= cutoffNumTraj);    
        %get trajStructDims
        [postureList,numPostures,targetList,numTargets,numChannels,numConditions] = getTrajStructDimensions(trajStruct);
        %Get minimum number of condition trials and timestamps
        [minNumCondTrials] = getMinNumCondTrials(trajStruct);
        [minNumTimestamps] = getMinNumTimestamps(trajStruct); 
        % Get field name for comparisons below
        secondField = trajFields{2};
        capitalizedSecondField = [upper(secondField(1)) secondField(2:end)];
        fieldName = ['avg' capitalizedSecondField]; % The second field is the one we use, always making zSmoothFR the first field

        %% Preallocate sessionResultStruct - Compare posture A target A to posture B target B
        sessionResultStruct = struct('postureA',[],'targetA',[],'postureB',[],'targetB',[],'difference',[]);
        sessionResultStructInd = 1;
        for postureA = postureList
            withinPostureTargetList = unique([trajStruct([trajStruct.posture]==postureA).target]);       
            for targetA = withinPostureTargetList
                for postureB = postureList(postureList>=postureA)
                    if any([trajStruct.posture]==postureB & [trajStruct.target]==targetA)
                        sessionResultStruct(sessionResultStructInd).postureA = postureA;
                        sessionResultStruct(sessionResultStructInd).targetA = targetA;
                        sessionResultStruct(sessionResultStructInd).postureB = postureB;
                        sessionResultStruct(sessionResultStructInd).targetB = targetA;
                        sessionResultStruct(sessionResultStructInd).difference = NaN(1,numIterations);
                        sessionResultStructInd = sessionResultStructInd + 1;
                    end
                end
            end
        end
        
        %% Do computation
        numPts = minNumTimestamps;
        for i = 1:numIterations
            %Split trajStruct into two groups
            [trajStruct1,trajStruct2] = splitDataforCVKinematicComparison(trajStruct,minNumCondTrials,binWidth); 
            %Make every comparison
            for postureA = postureList
                withinPostureTargetList = unique([trajStruct([trajStruct.posture]==postureA).target]);       
                for targetA = withinPostureTargetList
                    for postureB = postureList(postureList>=postureA)
                        if any([trajStruct.posture]==postureB & [trajStruct.target]==targetA)
                            
                            % Get trajectories for comparison
                            cond1 = find([trajStruct1.target]==targetA & [trajStruct1.posture]==postureA);
                            traj1 = trajStruct1(cond1).(fieldName).traj;  % Predicted trajectory
                            if postureA == postureB % Use trajStruct2 for within-condition comparisons
                                cond2 = find([trajStruct2.target]==targetA & [trajStruct2.posture]==postureB);
                                traj2 = trajStruct2(cond2).(fieldName).traj;  % Comparison trajectory
                            else % Use trajStruct1 for across-condition comparisons
                                cond2 = find([trajStruct1.target]==targetA & [trajStruct1.posture]==postureB);
                                traj2 = trajStruct1(cond2).(fieldName).traj;  % Comparison trajectory
                            end

                            % Get tempNumPts
                            if min([size(traj1,1),size(traj2,1)]) < numPts
                                tempNumPts = min([size(traj1,1),size(traj2,1)]);
                            else
                                tempNumPts = numPts;
                            end
                            %Compute comparison difference
                            difference = getMeanDist(traj1,traj2,tempNumPts);
                            %Store results in sessionResultStruct
                            sessionResultStructInd = find([sessionResultStruct.postureA]==postureA & ...
                                [sessionResultStruct.targetA]==targetA & [sessionResultStruct.postureB]==postureB);
                            sessionResultStruct(sessionResultStructInd).difference(i) = difference;                 
                        end
                    end
                end
            end
        end

        %Add results to resultStruct
        resultStruct(structInd).dataset = dataset;
        resultStruct(structInd).animal = dataset(1);
        resultStruct(structInd).result = sessionResultStruct;
        structInd = structInd + 1;
    end

%% Collect results for each monkey
    %Get monkeyList
    for i = 1:numel(resultStruct)
        resultMonkeyList{i} = resultStruct(i).animal;
    end
    monkeyList = unique(resultMonkeyList);
    numMonkeys = numel(monkeyList);
    
    %Create monkey result struct (reference posture 1)
    monkeyResultStruct = struct('monkey',[],'acrossPostureDifference',[]);
    monkeyInd = 1;
    for monkey = monkeyList
      tempResultStruct = resultStruct(strcmp(resultMonkeyList,monkey{1,1}));
      acrossPostureDifference = struct('postureDiff',[],'difference',[]);
      
      for session = 1:numel(tempResultStruct)
          dataset = tempResultStruct(session).dataset;
          result = tempResultStruct(session).result;
          postureA = [result.postureA];
          postureB = [result.postureB];
          targetA = [result.targetA];
          
          if ismember(dataset,{'N20171215','N20180221'}) %Nigel BCI: all postures are '1 away'
               postureRange = 1;
          else
              postureRange = max(postureA) - min(postureA);
          end
          
          for postureDiff = 0:1:postureRange
              
              % Collect trajectory differences
              if ismember(dataset,{'N20171215','N20180221'}) %Nigel BCI: all postures are '1 away'
                  difference = [result((abs(postureB-postureA)>0)==postureDiff).difference];
              else
                  difference = [result(abs(postureB-postureA)==postureDiff).difference];
              end
              
              % Store in struct
              if ismember(postureDiff, [acrossPostureDifference.postureDiff])
                  acrossPostureDifferenceIdx = find([acrossPostureDifference.postureDiff]==postureDiff);
                  acrossPostureDifference(acrossPostureDifferenceIdx).difference = [acrossPostureDifference(acrossPostureDifferenceIdx).difference,difference];
              else
                  if (size(acrossPostureDifference,2)==1) && (isempty(acrossPostureDifference(1).difference))
                      acrossPostureDifferenceIdx = 1;
                  else
                    acrossPostureDifferenceIdx = size(acrossPostureDifference,2) + 1;
                  end
                  acrossPostureDifference(acrossPostureDifferenceIdx).postureDiff = postureDiff;
                  acrossPostureDifference(acrossPostureDifferenceIdx).difference = difference;
              end
          end
      end
        monkeyResultStruct(monkeyInd).monkey = monkey;
        monkeyResultStruct(monkeyInd).acrossPostureDifference = acrossPostureDifference;
        monkeyInd = monkeyInd + 1;
    end
      
%% Plot histograms
    monkeyInd = 1;
    for monkey = monkeyList
        f=figure; hold on;
        acrossPostureDifference = monkeyResultStruct(strcmp([monkeyResultStruct.monkey],monkey{1,1})).acrossPostureDifference;
        postureDiffList = [acrossPostureDifference.postureDiff];
       
        for postureDiff = postureDiffList
           ax(postureDiff+1) = subplot(length(postureDiffList),1,postureDiff+1);
           difference = acrossPostureDifference([acrossPostureDifference.postureDiff]==postureDiff).difference;
           histogram(difference, 'Normalization', 'probability');
           title(['Posture difference: ',num2str(postureDiff)])
           ylabel('Probability');
        end
        xlabel('Mean Euclidean distance between trajectories');
        linkaxes(ax, 'x');
        
        if saveFig
            saveas(gcf,fullfile(saveDir,[task,'_goalSigVarExpl.svg']));
        end
        
        clearvars ax;
    end


%% Local functions  
    %Get mean dist
    function dist = getMeanDist(traj1,traj2,numPts)
        dist = 0;
        for i = 1:numPts
            dist = vecnorm(traj1(i,:)-traj2(i,:)) + dist;
        end
        dist = dist/numPts;
    end
    
  
    